# POJ2019 1000-1099

- [X] 1000

|整数|
|:--|
|这题是用来测试提交和编译器能不能用的……|

- [X] 1001

|高精度|
|:--|
|高精度实数。需要注意的点包括：整数部分前导0；小数部分末尾0；结果是整数（省略小数点）；0本身（0.0，0000，.0000，甚至只有.，其结果都是0）|

- [X] 1002

|字符串|
|:--|
|字符串处理+简单统计。我的思路是把输入字符串转换后存入map，输出时遍历map即可（因为是平衡树也不用排序）。
map的键采用string会超时，改为int后仍然有1秒多的运行时间（且int需要注意0）。今时今日习惯于C++的我瑟瑟发抖|

- [X] 1003

|数列|
|:--|
|打表题，把数列和打出来就行。精度用double没问题。|

- [X] 1004

|实数|
|:--|
|超水题，算12个double的平均值。|

- [X] 1005

|几何|
|:--|
|题意是每年这个半圆扩大50.0平方迈，问哪年年底扩大到输入坐标处。对于输入(x,y)，以其为圆边界上的点，计算半圆的面积，除以50.0并向上取整后得到答案|

- [X] 1006

|[中国剩余定理](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)|
|:--|
|典型的中国剩余定理，这里通过手算[求出系数](https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Existence_(direct_construction))，乘以输入得到结果。求系数的过程中用到了[模逆元](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)|

- [X] 1007

|归并排序，逆序对问题|
|:--|
|典型的逆序对，在归并排序中插入逆序对计算代码即可|

- [X] 1008

|日历转换|
|:--|
|两种历法间的转换，简单|

- [X] 1009

|模拟+剪枝|
|:--|
|挺麻烦的模拟题。我基本的解题思路是这样的：
首先，一个像素的边缘检测结果只可能与它的上一行、它所在的行和它的下一行有关，所以在遍历每行时我维护了当前行和相邻行的信息
然后，对于遍历到的某一行，我用统一的列指针扫描它和它的相邻行
剪枝1：列指针扫描时，边缘检测结果出现变化的情况，仅可能由当前行或相邻行的像素值在扫描处邻域内的变化引起。那么求出像素值产生变化的扫描处，对于边缘检测结果不可能改变的位置就只需要计算一次即可
剪枝2：一个RLE对可能包含多行，中间重复行的边缘检测结果是连续的0，求出重复行的数量，就只需要向答案中添加0即可
思路可以说比较朴素，但写起来还是很麻烦的。
找到了[另一篇题解](http://blog.sina.com.cn/s/blog_6e63f59e01012mxb.html)，我觉得比我的好写，不过这种思路似乎需要特判一个区域外的点？|

- [X] 1010

|搜索+剪枝，24点问题|
|:--|
|这题属于用已有的数字凑出目标数字的一类问题，我起了个外号叫“24点问题”（“24点”是一种上古扑克游戏）
在这种问题中搜索顺序是比较重要的，顺序本身也是一种剪枝
然而这次使用stl之后疯狂剪枝才没有TLE，上次c风格代码不知道为啥没做什么剪枝就过了。我之前的题解写的是“暴力可过”……|

- [X] 1011

|搜索+剪枝，24点问题|
|:--|
|经典的Sticks，这题思路是从小到大枚举可能的长棍长度（是小棍长度总和的因数），并搜索判定其是否可行
判定时，是用实际存在的小棍来拼成目标的虚拟长棍，有几个剪枝是比较重要的：
1 从大到小排序。若剩下小棍不足以拼成长棍，返回不可行
2 当开始判定一个新的长棍时，如果存在一根小棍，使得拼上这根小棍后无法完成当前长棍，则当前长棍长度是不可行的（因为所有小棍都要拼到长棍里去）。于是可以任选小棍，拼棍失败时返回不可行。为了尽可能减少搜索支，当然是每次选取最长的小棍来拼了
3 若一根小棍判定为不可行，跳过与其长度相同的小棍|

- [X] 1012

|递推，打表，约瑟夫问题|
|:--|
|这次一开始的解题思路还是打表，因为k的取值只有1 ~ 13，把它们暴力求出来后就可以写在数组里无脑输出了
使用的约束条件是：每次去掉一个人之后，从被去掉的人的下一个人开始编号1，则下一个坏人的编号等于（m % 剩下人数），且这个编号是有范围的
比如，还剩第i个坏人时，总人数 = k + i，坏人数 = i，下一个坏人的编号位于[-i+1+t, t]中，其中t取值[0, i]
取尽所有的t，则剩第i个坏人时，下一个坏人编号 = m % (k + i) 位于[-i+1, i]中，故m位于[x(k+i)-i+1, x(k+i)+i]中
固定k时，利用线段树求出对所有i都可行的m的区间，枚举区间内的数，判断是否可行即可
写判断时使用了直白的暴力模拟判断，所以这个方法在k=13时约消耗2s的时间
**但是，判断这一步是可以递推的**！先将所有人编号为0 ~ 2k - 1；出局1个人后，原来0号位置的人不变，重编号为0 ~ 2k - 2，依此类推
递推方法是：设gameOver[i] = 第i轮中出局的人的编号，i取值[1, k]
则gameOver[0] = 0; gameOver[i] = (gameOver[i - 1] - 1 + m) % (2 * k - i + 1)
一旦gameOver[i] < k，代表前k个人中有人出局，就判为不可行，递增m
这里的m是可以暴力枚举的，复杂度O(mk)，一开始打表1 ~ 13即可任意输出
（说起来有点丢人，区间+线段树本来是为了缩小暴力枚举复杂度的，反而成了程序进一步优化的瓶颈。冷静分析，每一个影响复杂度的因子都考虑一下，才是更好的解题之道啊）|

- [X] 1013

|逻辑|
|:--|
|使用排除法得到假货币编号
1 天平两边相等时，排除所有放在天平上的硬币
2 天平两边不等时，记录硬币较轻或较重的可能性，排除既可能轻又可能重的硬币，排除没有放在天平上的硬币
题目保证有唯一解，故遍历编号，找到有嫌疑的直接输出即可|

- [X] 1014

|寻找规律，24点问题|
|:--|
|题目的本体是用多个数凑齐这些数和的一半，搜索部分可以用与POJ1011（Sticks）类似的写法
但是数字和可能非常大，需要考虑减小搜索树。
观察到凑数的过程中，参与数的和与不参与数的和最多差6，否则可以从多的一方取数放到少的一方，使这个差变小
故可以认为每个数最多存在6/7（保持奇偶性）个，所以输入时对数量做截取操作即可
（这道题我后来瞎猜，每个数限制在60个以内也过了……还是要知其所以然的）|

- [X] 1015

|动态规划，24点问题（变体）|
|:--|
|题目变量命名明显暗示DP……那就用DP做
粗看是一道24点问题，但用搜索做肯定超时。注意到投票结果范围为0到20，两派投票差的取值范围也就-20到20这41个数，所以以下递推式成立
`dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-1][k-(d[i]-p[i])]`
其中i表示候选人，j表示已经选出的候选人数，k表示已选出的候选人投票差的和（sum(d[i] - p[i])），dp[i][j][k]表示在i，j，k确定时两派投票和的和（sum(d[i] + p[i])）
k的取值范围为[-20 * m, 20 * m], 故时间复杂度O(nm^2)，dp总大小为200 * 20 * 840，时空都不会超|

- [X] 1016

|字符串，模拟|
|:--|
|注意读题，按题目要求一步步模拟即可|

- [ ] 1017

||
|:--|
||

- [ ] 1018

||
|:--|
||

- [ ] 1019

||
|:--|
||

- [ ] 1020

||
|:--|
||

- [ ] 1021

||
|:--|
||
