# POJ2019 1000-1099

- [X] 1000

|整数|
|:--|
|这题是用来测试提交和编译器能不能用的……|

- [X] 1001

|高精度|
|:--|
|高精度实数。需要注意的点包括：整数部分前导0；小数部分末尾0；结果是整数（省略小数点）；0本身（0.0，0000，.0000，甚至只有.，其结果都是0）|

- [X] 1002

|字符串|
|:--|
|字符串处理+简单统计。我的思路是把输入字符串转换后存入map，输出时遍历map即可（因为是平衡树也不用排序）。
map的键采用string会超时，改为int后仍然有1秒多的运行时间（且int需要注意0）。今时今日习惯于C++的我瑟瑟发抖|

- [X] 1003

|数列|
|:--|
|打表题，把数列和打出来就行。精度用double没问题。|

- [X] 1004

|实数|
|:--|
|超水题，算12个double的平均值。|

- [X] 1005

|几何|
|:--|
|题意是每年这个半圆扩大50.0平方迈，问哪年年底扩大到输入坐标处。对于输入(x,y)，以其为圆边界上的点，计算半圆的面积，除以50.0并向上取整后得到答案|

- [X] 1006

|[中国剩余定理](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)|
|:--|
|典型的中国剩余定理，这里通过手算[求出系数](https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Existence_(direct_construction))，乘以输入得到结果。求系数的过程中用到了[模逆元](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)|

- [X] 1007

|归并排序，逆序对问题|
|:--|
|典型的逆序对，在归并排序中插入逆序对计算代码即可|

- [X] 1008

|日历转换|
|:--|
|两种历法间的转换，简单|

- [X] 1009

|模拟+剪枝|
|:--|
|挺麻烦的模拟题。我基本的解题思路是这样的：
首先，一个像素的边缘检测结果只可能与它的上一行、它所在的行和它的下一行有关，所以在遍历每行时我维护了当前行和相邻行的信息
然后，对于遍历到的某一行，我用统一的列指针扫描它和它的相邻行
剪枝1：列指针扫描时，边缘检测结果出现变化的情况，仅可能由当前行或相邻行的像素值在扫描处邻域内的变化引起。那么求出像素值产生变化的扫描处，对于边缘检测结果不可能改变的位置就只需要计算一次即可
剪枝2：一个RLE对可能包含多行，中间重复行的边缘检测结果是连续的0，求出重复行的数量，就只需要向答案中添加0即可
思路可以说比较朴素，但写起来还是很麻烦的。
找到了[另一篇题解](http://blog.sina.com.cn/s/blog_6e63f59e01012mxb.html)，我觉得比我的好写，不过这种思路似乎需要特判一个区域外的点？|

- [X] 1010

|搜索+剪枝，24点问题|
|:--|
|这题属于用已有的数字凑出目标数字的一类问题，我起了个外号叫“24点问题”（“24点”是一种上古扑克游戏）
在这种问题中搜索顺序是比较重要的，顺序本身也是一种剪枝
然而这次使用stl之后疯狂剪枝才没有TLE，上次c风格代码不知道为啥没做什么剪枝就过了。我之前的题解写的是“暴力可过”……|

- [X] 1011

|搜索+剪枝|
|:--|
|经典的Sticks，这题思路是从小到大枚举可能的长棍长度（是小棍长度总和的因数），并搜索判定其是否可行
判定时，是用实际存在的小棍来拼成目标的虚拟长棍，有几个剪枝是比较重要的：
1 从大到小排序。若剩下小棍不足以拼成长棍，返回不可行
2 当开始判定一个新的长棍时，如果存在一根小棍，使得拼上这根小棍后无法完成当前长棍，则当前长棍长度是不可行的（因为所有小棍都要拼到长棍里去）。于是可以任选小棍，拼棍失败时返回不可行。为了尽可能减少搜索支，当然是每次选取最长的小棍来拼了
3 若一根小棍判定为不可行，跳过与其长度相同的小棍|

- [ ] 1012

||
|:--|
||

- [ ] 1013

||
|:--|
||

- [ ] 1014

||
|:--|
||

- [ ] 1015

||
|:--|
||
