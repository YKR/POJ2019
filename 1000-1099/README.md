# POJ2019 1000-1099

- [X] 1000

|整数|
|:--|
|这题是用来测试提交和编译器能不能用的……|

- [X] 1001

|高精度|
|:--|
|高精度实数。需要注意的点包括：整数部分前导0；小数部分末尾0；结果是整数（省略小数点）；0本身（0.0，0000，.0000，甚至只有.，其结果都是0）|

- [X] 1002

|字符串|
|:--|
|字符串处理+简单统计。我的思路是把输入字符串转换后存入map，输出时遍历map即可（因为是平衡树也不用排序）。
map的键采用string会超时，改为int后仍然有1秒多的运行时间（且int需要注意0）。今时今日习惯于C++的我瑟瑟发抖|

- [X] 1003

|数列|
|:--|
|打表题，把数列和打出来就行。精度用double没问题。|

- [X] 1004

|实数|
|:--|
|超水题，算12个double的平均值。|

- [X] 1005

|几何|
|:--|
|题意是每年这个半圆扩大50.0平方迈，问哪年年底扩大到输入坐标处。对于输入(x,y)，以其为圆边界上的点，计算半圆的面积，除以50.0并向上取整后得到答案|

- [X] 1006

|[中国剩余定理](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)|
|:--|
|典型的中国剩余定理，这里通过手算[求出系数](https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Existence_(direct_construction))，乘以输入得到结果。求系数的过程中用到了[模逆元](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)|

- [X] 1007

|归并排序，逆序对问题|
|:--|
|典型的逆序对，在归并排序中插入逆序对计算代码即可|

- [X] 1008

|日历转换|
|:--|
|两种历法间的转换，简单|

- [X] 1009

|模拟+剪枝|
|:--|
|挺麻烦的模拟题。我基本的解题思路是这样的：
首先，一个像素的边缘检测结果只可能与它的上一行、它所在的行和它的下一行有关，所以在遍历每行时我维护了当前行和相邻行的信息
然后，对于遍历到的某一行，我用统一的列指针扫描它和它的相邻行
剪枝1：列指针扫描时，边缘检测结果出现变化的情况，仅可能由当前行或相邻行的像素值在扫描处邻域内的变化引起。那么求出像素值产生变化的扫描处，对于边缘检测结果不可能改变的位置就只需要计算一次即可
剪枝2：一个RLE对可能包含多行，中间重复行的边缘检测结果是连续的0，求出重复行的数量，就只需要向答案中添加0即可
思路可以说比较朴素，但写起来还是很麻烦的。
找到了[另一篇题解](http://blog.sina.com.cn/s/blog_6e63f59e01012mxb.html)，我觉得比我的好写，不过这种思路似乎需要特判一个区域外的点？|

- [X] 1010

|搜索+剪枝，24点问题|
|:--|
|这题属于用已有的数字凑出目标数字的一类问题，我起了个外号叫“24点问题”（“24点”是一种上古扑克游戏）
在这种问题中搜索顺序是比较重要的，顺序本身也是一种剪枝
然而这次使用stl之后疯狂剪枝才没有TLE，上次c风格代码不知道为啥没做什么剪枝就过了。我之前的题解写的是“暴力可过”……|

- [X] 1011

|搜索+剪枝，24点问题|
|:--|
|经典的Sticks，这题思路是从小到大枚举可能的长棍长度（是小棍长度总和的因数），并搜索判定其是否可行
判定时，是用实际存在的小棍来拼成目标的虚拟长棍，有几个剪枝是比较重要的：
1 从大到小排序。若剩下小棍不足以拼成长棍，返回不可行
2 当开始判定一个新的长棍时，如果存在一根小棍，使得拼上这根小棍后无法完成当前长棍，则当前长棍长度是不可行的（因为所有小棍都要拼到长棍里去）。于是可以任选小棍，拼棍失败时返回不可行。为了尽可能减少搜索支，当然是每次选取最长的小棍来拼了
3 若一根小棍判定为不可行，跳过与其长度相同的小棍|

- [X] 1012

|递推，打表，约瑟夫问题|
|:--|
|这次一开始的解题思路还是打表，因为k的取值只有1 ~ 13，把它们暴力求出来后就可以写在数组里无脑输出了
使用的约束条件是：每次去掉一个人之后，从被去掉的人的下一个人开始编号1，则下一个坏人的编号等于（m % 剩下人数），且这个编号是有范围的
比如，还剩第i个坏人时，总人数 = k + i，坏人数 = i，下一个坏人的编号位于[-i+1+t, t]中，其中t取值[0, i]
取尽所有的t，则剩第i个坏人时，下一个坏人编号 = m % (k + i) 位于[-i+1, i]中，故m位于[x(k+i)-i+1, x(k+i)+i]中
固定k时，利用线段树求出对所有i都可行的m的区间，枚举区间内的数，判断是否可行即可
写判断时使用了直白的暴力模拟判断，所以这个方法在k=13时约消耗2s的时间
**但是，判断这一步是可以递推的！**先将所有人编号为0 ~ 2k - 1；出局1个人后，原来0号位置的人不变，重编号为0 ~ 2k - 2，依此类推
递推方法是：设gameOver[i] = 第i轮中出局的人的编号，i取值[1, k]
则gameOver[0] = 0; gameOver[i] = (gameOver[i - 1] - 1 + m) % (2 * k - i + 1)
一旦gameOver[i] < k，代表前k个人中有人出局，就判为不可行，递增m
这里的m是可以暴力枚举的，复杂度O(mk)，一开始打表1 ~ 13即可任意输出
（说起来有点丢人，区间+线段树本来是为了缩小暴力枚举复杂度的，反而成了程序进一步优化的瓶颈。冷静分析，每一个影响复杂度的因子都考虑一下，才是更好的解题之道啊）|

- [ ] 1013

||
|:--|
||

- [ ] 1014

||
|:--|
||

- [ ] 1015

||
|:--|
||
