# POJ2019 1000-1099

- [X] 1000

|整数|
|:--|
|这题是用来测试提交和编译器能不能用的……|

- [X] 1001

|高精度|
|:--|
|高精度实数。需要注意的点包括：整数部分前导0；小数部分末尾0；结果是整数（省略小数点）；0本身（0.0，0000，.0000，甚至只有.，其结果都是0）|

- [X] 1002

|字符串|
|:--|
|字符串处理+简单统计。我的思路是把输入字符串转换后存入map，输出时遍历map即可（因为是平衡树也不用排序）。
map的键采用string会超时，改为int后仍然有1秒多的运行时间（且int需要注意0）。今时今日习惯于C++的我瑟瑟发抖|

- [X] 1003

|数列|
|:--|
|打表题，把数列和打出来就行。精度用double没问题。|

- [X] 1004

|实数|
|:--|
|超水题，算12个double的平均值。|

- [X] 1005

|几何|
|:--|
|题意是每年这个半圆扩大50.0平方迈，问哪年年底扩大到输入坐标处。对于输入(x,y)，以其为圆边界上的点，计算半圆的面积，除以50.0并向上取整后得到答案|

- [X] 1006

|[中国剩余定理](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)|
|:--|
|典型的中国剩余定理，这里通过手算[求出系数](https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Existence_(direct_construction))，乘以输入得到结果。求系数的过程中用到了[模逆元](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)|

- [X] 1007

|归并排序，逆序对问题|
|:--|
|典型的逆序对，在归并排序中插入逆序对计算代码即可|

- [X] 1008

|日历转换|
|:--|
|两种历法间的转换，简单|

- [X] 1009

|模拟+剪枝|
|:--|
|挺麻烦的模拟题。我基本的解题思路是这样的：
首先，一个像素的边缘检测结果只可能与它的上一行、它所在的行和它的下一行有关，所以在遍历每行时我维护了当前行和相邻行的信息
然后，对于遍历到的某一行，我用统一的列指针扫描它和它的相邻行
剪枝1：列指针扫描时，边缘检测结果出现变化的情况，仅可能由当前行或相邻行的像素值在扫描处邻域内的变化引起。那么求出像素值产生变化的扫描处，对于边缘检测结果不可能改变的位置就只需要计算一次即可
剪枝2：一个RLE对可能包含多行，中间重复行的边缘检测结果是连续的0，求出重复行的数量，就只需要向答案中添加0即可
思路可以说比较朴素，但写起来还是很麻烦的。
找到了[另一篇题解](http://blog.sina.com.cn/s/blog_6e63f59e01012mxb.html)，我觉得比我的好写，不过这种思路似乎需要特判一个区域外的点？|

- [X] 1010

|搜索+剪枝，24点问题|
|:--|
|这题属于用已有的数字凑出目标数字的一类问题，我起了个外号叫“24点问题”（“24点”是一种上古扑克游戏）
在这种问题中搜索顺序是比较重要的，顺序本身也是一种剪枝
然而这次使用stl之后疯狂剪枝才没有TLE，上次c风格代码不知道为啥没做什么剪枝就过了。我之前的题解写的是“暴力可过”……|

- [X] 1011

|搜索+剪枝，24点问题|
|:--|
|经典的Sticks，这题思路是从小到大枚举可能的长棍长度（是小棍长度总和的因数），并搜索判定其是否可行
判定时，是用实际存在的小棍来拼成目标的虚拟长棍，有几个剪枝是比较重要的：
1 从大到小排序。若剩下小棍不足以拼成长棍，返回不可行
2 当开始判定一个新的长棍时，如果存在一根小棍，使得拼上这根小棍后无法完成当前长棍，则当前长棍长度是不可行的（因为所有小棍都要拼到长棍里去）。于是可以任选小棍，拼棍失败时返回不可行。为了尽可能减少搜索支，当然是每次选取最长的小棍来拼了
3 若一根小棍判定为不可行，跳过与其长度相同的小棍|

- [X] 1012

|递推，打表，约瑟夫问题|
|:--|
|这次一开始的解题思路还是打表，因为k的取值只有1 ~ 13，把它们暴力求出来后就可以写在数组里无脑输出了
使用的约束条件是：每次去掉一个人之后，从被去掉的人的下一个人开始编号1，则下一个坏人的编号等于（m % 剩下人数），且这个编号是有范围的
比如，还剩第i个坏人时，总人数 = k + i，坏人数 = i，下一个坏人的编号位于[-i+1+t, t]中，其中t取值[0, i]
取尽所有的t，则剩第i个坏人时，下一个坏人编号 = m % (k + i) 位于[-i+1, i]中，故m位于[x(k+i)-i+1, x(k+i)+i]中
固定k时，利用线段树求出对所有i都可行的m的区间，枚举区间内的数，判断是否可行即可
写判断时使用了直白的暴力模拟判断，所以这个方法在k=13时约消耗2s的时间
**但是，判断这一步是可以递推的**！先将所有人编号为0 ~ 2k - 1；出局1个人后，原来0号位置的人不变，重编号为0 ~ 2k - 2，依此类推
递推方法是：设gameOver[i] = 第i轮中出局的人的编号，i取值[1, k]
则gameOver[0] = 0; gameOver[i] = (gameOver[i - 1] - 1 + m) % (2 * k - i + 1)
一旦gameOver[i] < k，代表前k个人中有人出局，就判为不可行，递增m
这里的m是可以暴力枚举的，复杂度O(mk)，一开始打表1 ~ 13即可任意输出
（说起来有点丢人，区间+线段树本来是为了缩小暴力枚举复杂度的，反而成了程序进一步优化的瓶颈。冷静分析，每一个影响复杂度的因子都考虑一下，才是更好的解题之道啊）|

- [X] 1013

|逻辑|
|:--|
|使用排除法得到假货币编号
1 天平两边相等时，排除所有放在天平上的硬币
2 天平两边不等时，记录硬币较轻或较重的可能性，排除既可能轻又可能重的硬币，排除没有放在天平上的硬币
题目保证有唯一解，故遍历编号，找到有嫌疑的直接输出即可|

- [X] 1014

|寻找规律，24点问题|
|:--|
|题目的本体是用多个数凑齐这些数和的一半，搜索部分可以用与POJ1011（Sticks）类似的写法
但是数字和可能非常大，需要考虑减小搜索树。
观察到凑数的过程中，参与数的和与不参与数的和最多差6，否则可以从多的一方取数放到少的一方，使这个差变小
故可以认为每个数最多存在6/7（保持奇偶性）个，所以输入时对数量做截取操作即可
（这道题我后来瞎猜，每个数限制在60个以内也过了……还是要知其所以然的）|

- [X] 1015

|动态规划，24点问题（变体）|
|:--|
|题目变量命名明显暗示DP……那就用DP做
粗看是一道24点问题，但用搜索做肯定超时。注意到投票结果范围为0到20，两派投票差的取值范围也就-20到20这41个数，所以以下递推式成立
`dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-1][k-(d[i]-p[i])]`
其中i表示候选人，j表示已经选出的候选人数，k表示已选出的候选人投票差的和（sum(d[i] - p[i])），dp[i][j][k]表示在i，j，k确定时两派投票和的和（sum(d[i] + p[i])）
k的取值范围为[-20 * m, 20 * m], 故时间复杂度O(nm^2)，dp总大小为200 * 20 * 840，时空都不会超|

- [X] 1016

|字符串，模拟|
|:--|
|注意读题，按题目要求一步步模拟即可|

- [X] 1017

|几何，搜索，数学计算，贪心|
|:--|
|这道题粗一看是一道搜索题，需要尽可能填满大小为6x6的二维矩阵组，使它们的总数最小
但是仔细分析题目，因为只有1x1到6x6这6种矩阵，其实可以分情况讨论
6x6 直接填满6x6
5x5 1个6x6只能容纳1个5x5，空出11个1x1位置
4x4 1个6x6只能容纳1个4x4，空出5个2x2位置
3x3 1个6x6可以容纳1~4个3x3
　　1个3x3时，空出5个2x2位置和7个1x1位置
　　2个3x3时，空出3个2x2位置和6个1x1位置
　　3个3x3时，空出1个2x2位置和5个1x1位置
2x2 1个6x6可以容纳9个2x2
1x1 1个6x6可以容纳36个1x1
这样就可以用贪心来做了
对于4x4，5x5，6x6矩阵，贪心策略是把它们各自放入1个6x6矩阵中，并记录空出的2x2和1x1位置
对于3x3矩阵，贪心策略是把它们4个一组放入6x6矩阵中，余下的放入1个新的6x6矩阵，并记录空出的2x2和1x1位置
对于2x2矩阵，若填满空出的位置后仍有剩余，则把它们9个一组放入6x6矩阵中，余下的放入1个新的6x6矩阵，并记录空出的1x1位置；若未填满空出的位置，则余下每个空出的2x2位置转换成4个1x1位置
对于1x1矩阵，若填满空出的位置后仍有剩余，则把它们36个一组放入6x6矩阵中，余下的放入1个新的6x6矩阵|

- [X] 1018

|动态规划|
|:--|
|题目中总体带宽 == min(各设备带宽)，故搜索时需要遍历带宽下界，在带宽下界确定的情况下求得花费的最优解
首先做一下预处理：对于每种设备，先按带宽从小到大排序，然后去掉带宽小但花费大的供应商；把每个设备的带宽记录到候选下界中，并去掉重复值。此时，每种设备从前往后的带宽和花费都是单调不减的。
那么，动态规划递推方程如下：
`dp[i][lowerbound] = dp[i-1][lowerbound] + price[k]`
其中，i表示当前设备种类，lowerbound表示带宽下界，k表示使bandwidth[i][k]刚好大于或等于lowerbound的那一个k（由于单调性，price[k]一定是当前最小的设备价格）
因为有单调性，k可以随着lowerbound增加而增加，此时内循环消耗时间 == lowerbounds.size + bandwidth[i].size
因为lowerbounds.size上界是n * max(m)，bandwidth[i].size上界是max(m)，故总体的最坏时间复杂度为O(n^2 * max(m))
因为n <= 100，max(m) <= 100，故不会超时|

- [X] 1019

|递推|
|:--|
|直白的递推题，寻找第n位数字时需要一层层剥开累积长度
令m为n == INT_MAX时，等差数列最大的数字，则可以先打表求出最大数字从1逐渐递增到m时的累积长度，二分（或枚举，m不大）查找n在其中的位置，然后找出n具体为哪一个数字的哪一位。
然而我这次写得有点过于复杂了，还求了一层x位数的终止位置，关于n的运算也差点把自己搞晕，最后开了个对拍才把程序中的所有错误找出来……|

- [X] 1020

|搜索+剪枝，24点问题（变体）|
|:--|
|二维版本的24点问题……1234是剪枝策略
1 小块平方和要等于总面积
2 边长大于总边长一半的小块顶多只有一个
记录大块中切掉的小块是用的长度为总边长的一维数组cutted，每个数字记录从选定的一边到切口的距离（这中间的部分都被切掉了）。一维数组处理比二维数组简单高效，且因为大块需要全部分成小块，中间不允许出现空洞，故使用一维数组是可以的。
搜索策略是每次找寻离选定边最近的切口（cutted中最小的元素），探明它的宽度和到另一边的距离，然后试图在其上分割可行的小块。
3 试图分割时，只尝试从切口最左边开始分割。这样剪枝的原因是：若可行小块边长 == 切口宽度，那么自然只有这种选择；若可行小块边长 < 切口宽度，要让这个切口被完全切出，必然存在其它小块可以组成宽度为（切口宽度 - 可行小块边长）的切法。既然其他小块也可能在这个切口处被枚举到，那么这种情况已经被包含了，所以只需要尝试从切口最左边开始分割即可
4 尝试一次某大小的小块后，跳过同样大小的小块
这些搜索和剪枝策略与一维的24点问题有点神似……老实说这道题我是看着上次的解法写的，因为之前思路走岔了总想用贪心。老老实实按照搜索问题的思路去想、按24点问题的搜索剪枝策略去扩展，难道就做不出来吗？未必吧。下次遇到这种题还是别老想着走捷径了|

- [X] 1021

|图像处理，搜索，哈希|
|:--|
|这题最直接的做法是搜索所有的连通块，当两幅图中的两连通块长宽相等、面积相等时，通过旋转、翻转暴力判断它们是否一致。我之前的解法就是这样的
但是现在，看到这题的题干我第一反应是这是一个图像处理/图像搜索的问题。如果每个连通块都能生成一个唯一表示，且此唯一表示是旋转、翻转不变的，那么判断两连通块一致只需要对比它们的唯一表示即可。特殊地，这个表示可以是一个hash值，也可以是sift特征向量之类的
关于hash，网上找到的解法多是“求所有点之间距离的平方和”；特征向量也有“求所有点向四个方向扩展的距离和”这样的解法。但是，这两个解法是错误的，之所以能过题也就是因为题目数据较弱，没有卡住它们而已。下面举反例
1 求所有点之间距离的平方和
我们来分析一下这个方法。算式变换如下：
`hash = sigma(distance(pi, pj) ^ 2) = sigma((xi - xj) ^ 2 + (yi - yj) ^ 2)`  
`=> hash = sigma((xi - xj) ^ 2) + sigma((yi - yj) ^ 2)`
因为x，y都是整数，所以(xi - xj) ^ 2，(yi - yj) ^ 2的取值是完全平方数。对于行来说，当xi - xj == k时，一共有多少个k ^ 2呢？答案是所有行数相差k的两行的点数相乘的和，对于列来说同理。设col[t]为第t列的点个数，row[t]为第t行的点个数，则上一句话的形式化表述如下：
`hash = sigma(row[xi] * row[xi + k] * k ^ 2) + sigma(col[yi] * col[yi + k] * k ^ 2)`
那么可以看出，若两个点阵每行、每列的点数都相同，它们的hash值也会是相同的；但是若存在满足行列点数相同但是不同构的点阵，这个判定方法就是错误的。
这样的两个点阵是否存在？很不幸，这是存在的，还不难举出来。下面是我的反例：（X表示有点的格子，O表示空白的格子）
`XXXOXX <> XOXXXX`  
`XOXXXO <> XXXOXO`
下面是POJ评论区大牛oyashiroshama的反例：
`XXXO <> XOXX`  
`XOXX <> XXXO`  
`XXXX <> XXXX`
假如求的不是平方和，而是距离和，或者三次方和，是否还会有反例？我没有进一步验证，不过我倾向于认为反例存在。而且非偶数次幂会有开根号和精度问题
2 求所有点向四个方向扩展的距离和。这个方法生成了一个长度为点数的向量，排序后才是用于判定的特征向量
直接举反例：
`OXO <> OOX`  
`XXX <> XXX`  
`OXO <> OOX`
左边特征向量为[2, 2, 2, 2, 4]，右边特征向量为[2, 2, 2, 2, 4]，相等但不同构
题目数据可能过于弱了，这样的例子都没卡住……
3 还有题解一上来就说是图同构问题。真的没必要把问题变成NP的……当然它们的解法也不是用的判定图同构的算法
4 说一下我最后拿出来的解法。这个解法复杂度感觉跟暴力差不多……
我选定的途径是将点阵转换为旋转、翻转不变的特征。特征的设计包含两个部分：
①点阵的长宽（width取长宽中较短的一个，height取较长的一个）
②点阵旋转、翻转后共有8种可能的表示，取8种可能中**字典序**最大的那一个，然后把各行首尾相接做成一维向量
是的，这个策略非常暴力……字典序也真是够了，还可以用来排序
“因为根据长宽和一维向量可以唯一复现出点阵，所以这个解法是正确的”
如果点阵长宽的取值能更小心的话，上面那句话还是成立的
但是恰恰是长宽的取值产生了问题。按照目前的取值方法（width = min, height = max），有可能会有两个长宽互换的点阵，它们的特征表示相同，但实际上并不同构
修复这个问题的方法是：若width > height，则翻转当前点阵使width < height，并去掉8种可能中height > width的四种
// 但是……既然数据没把我这个解法里的小小瑕疵卡住，而我又知道怎么改，且懒得写，那就这样了
算了我还是改过来了……改动后没有翻转操作，但在width != height时去掉了height > width的四种情况。这样，结果就是正确的了
另外，我在生成8种表示时，并没有直接复制并变换点阵，而是用8个方向不同的自定义“指针”扫描矩阵。这样并没有减少时间复杂度，不过还是减少了时间的系数，并省掉了一些额外的空间
5 一点思考
关于hash：设计一种hash算法是不容易的，首先hash值的冲突概率要足够低，然后对于本题特有的旋转、翻转不变性，应该要对旋转对称的点或全部点做全局操作（sum/average，max/min，variance，etc.）而不能指定跟方向有关的某个或几个点。距离平方和是一个尝试，但不够好。另外，流行的hash方法中似乎没有强调旋转、翻转不变的，所以像SHA之类的方法无法直接用到这题上来
关于特征向量：能不能使用sift之类的算子？我认为可以用来搜索大致匹配的连通块对，但是这题里的局部特征有时会非常小，几个像素用sift的效果可能并不如意，这样的话实际消耗的时间不一定比得过暴力算法；还有就是sift特征的生成跟采样有关，实现采样又是一个大问题。所以，可以用，但手写很麻烦，所以没必要……|

- [X] 1022

|包围盒|
|:--|
|题意：判断四维空间里的一堆立方体是否是连通的，若是，计算它的包围盒大小
漫水填充法搜索，在判定连通的同时更新包围盒即可|

- [X] 1023

|位运算|
|:--|
|可被Fun Number System表示的数，可以写成如下形式：
`x = 1 * sigma(2 ^ n0) + 0 * sigma(2 ^ n1) + 0 * sigma(2 ^ n2) + (-1) * sigma(2 ^ n3)`
其中，n0，n1 ∈ {p}；n2，n3 ∈ {n}；n0，n3的比特位为1；n1，n2的比特位为0
设x'为`x' = 1 * sigma(2 ^ n0) + 0 * sigma(2 ^ n1) + 1 * sigma(2 ^ n2) + 0 * sigma(2 ^ n3)`
显然x'的二进制表示就是将x的Fun Number表示中n部分的0变1、1变0的结果
且`x' - x = 1 * sigma(2 ^ n2) + 1 * sigma(2 ^ n3)`
故x' - x的二进制表示就是将x的Fun Number表示的p部分全变0、n部分全变1的结果
那么，求出(x' - x)，就求出了x'；根据x'的二进制表示，就可以得到x的Fun Number表示
写的时候要考虑k == 64的情况，我这里使用了unsigned long long，当然也可以用高精度解决
（这题的数据非常水，我一个在k == 64时有错误的程序不小心交上去结果AC了）|

- [X] 1024

|BFS，最短路|
|:--|
|这题的基本要求是找出最短路并判断它是否唯一。因为是方格矩阵，求最短路可以用BFS来做
然后就是判断墙壁是否冗余。我这里是暴力枚举每一面墙，去掉之后再调用BFS看看结果是否不变。虽然能过，但不知道有没有复杂度更小的方法
这题的题目巨长，很容易看漏条件……我就看漏了一条，“The path ... may end anywhere in the maze”，没注意到这句话的我下意识以为终点是右上角，结果交上去的程序总WA，可以说非常气人了|

- [X] 1025

|模拟，主循环，有限状态机，优先队列，时序问题|
|:--|
|这题写起来比较花时间，但并不难。我的感觉就是写了这么多年OpenGL，套路还是比较清晰的。
题目中有一个大坑和几个小坑。大坑是题目中的“电梯每5秒可以上一个人”，这个“每5秒”指的是秒数是5的倍数，如12:13:45，08:52:10等，如果到达电梯的秒数不是5的倍数，就要等待到5的倍数秒才能上。小坑有一些，比如输出时是按特工编号字典序输出的
做这道题我首先选择了使用主循环这一实时程序的经典核心。时序问题用时间为主键的优先队列来处理，每次弹出的是下一次处理的时间和需要处理的特工，处理之后增加时间再塞入优先队列里。这里的时序调度其实跟系统线程切换有点类似，区别是这题里我能明确知道处理时间需要多久
具体到处理特工事件，我选择的方法是基于有限状态机的处理模式。关于时间安排的字符串在状态转移时产生，如 WaitingInFrontOfRoom -> StayInRoom 时，产生“Waiting in front of room ...”的字符串
大体的思路就是这样。不过写这道题的时候没有把状态机封装起来，而是用Enum表示状态，所以状态机和主循环的耦合度还是有点高……另外C++98的stringstream不算好用（没有转移构造函数，不能复制构造），结果为了它写了几个构造函数，比较冗余|

- [X] 1026

|矩阵乘法，快速幂|
|:--|
|本题中的加密方法实质上相当于用原串乘以置换矩阵的幂次，故可用矩阵乘法+快速幂解决；
因为置换操作与置换矩阵一一对应，且具有与置换矩阵十分相似的性质（结合律，结果一致等），故可以对题目中的“置换数组”使用快速幂，从而在时间复杂度更低（矩阵乘法O(n^2) -> 置换操作O(n)）的情况下得到正确的结果。总体时间复杂度O(nlogk)|

- [X] 1027

|模拟|
|:--|
|纯模拟，按照题目要求操作即可，注意读题|

- [X] 1028

|模拟|
|:--|
|关于网页访问的纯模拟，按题目要求来即可|

- [X] 1029

|逻辑|
|:--|
|方法与1013几乎完全相同，只是不保证唯一解，复制如下：
使用排除法得到假货币编号
1 天平两边相等时，排除所有放在天平上的硬币
2 天平两边不等时，记录硬币较轻或较重的可能性，排除既可能轻又可能重的硬币，排除没有放在天平上的硬币|

- [X] 1030

|模拟|
|:--|
|比较恶心的纯模拟，读题就挺麻烦的了……
题目中的关键是四个规则（1，2，A，B），其中1、2可以合并为一个，即对两个比赛都参与的队伍，按照它们在两者中的排名之和排序；A即只参与一个比赛的队伍，总排名取其并列队伍的总排名，当然这个规则有几个情况也需要考虑：①是没有两比赛都参与的并列队伍，这种情况放到规则B处理；②是有总排名不同且两者都参与的多支并列队伍，此时根据规则A，这种情况是无法确定总排名的，故舍弃当前只参与一个比赛的队伍，不让其参与总排名
规则B比较麻烦，对于只参与一个比赛的队伍，可能的总排名之前要有在它参与的比赛中排在它前面的所有队伍，之后同理。粗一看没有全局信息还不行，是不是要先把参与一个比赛的队伍信息放到总排名里再作调整；但是分析一下可知利用递推方法还是能得到正确结果的，即先应用规则1、2、A，然后对只参与一个比赛的队伍按照比赛排名从前到后逐一应用规则B，这样找出来的总排名还是合法的（关于只参与一个比赛队伍的总排名顺序，按照它们在所在比赛的排名值大小来排序）
实际写起来还挺麻烦的，首先就是输入数据很不好看，需要较多的处理；算法实现部分，我先用了一个map来实现规则1、2、A（用来排序和快速寻找排名之和），然后把它转成list方便插入条目；还有计算总排名中的队伍、用两个迭代器交替遍历比赛队伍等写起来麻烦、容易出错的段落。总之不是一件轻松事。
而且，还有一个拖慢效率的点：我写代码的思路是增量开发，因为规则多又互相纠缠，每做出一小部分就调试输出。这个在写的过程中规避了一些错误，但是在处理“只参与一个比赛队伍的总排名顺序”这一点上着实吃了一把“甲方加需求”的亏，把内外循环换了，规则B的代码几乎全改……|

- [ ] 1031

||
|:--|
||
