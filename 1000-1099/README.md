# POJ2019 1000-1099

- [X] 1000

|整数|
|:--|
|这题是用来测试提交和编译器能不能用的……|

- [X] 1001

|高精度|
|:--|
|高精度实数。需要注意的点包括：整数部分前导0；小数部分末尾0；结果是整数（省略小数点）；0本身（0.0，0000，.0000，甚至只有.，其结果都是0）|

- [X] 1002

|字符串|
|:--|
|字符串处理+简单统计。我的思路是把输入字符串转换后存入map，输出时遍历map即可（因为是平衡树也不用排序）。
map的键采用string会超时，改为int后仍然有1秒多的运行时间（且int需要注意0）。今时今日习惯于C++的我瑟瑟发抖|

- [X] 1003

|数列|
|:--|
|打表题，把数列和打出来就行。精度用double没问题。|

- [X] 1004

|实数|
|:--|
|超水题，算12个double的平均值。|

- [X] 1005

|几何|
|:--|
|题意是每年这个半圆扩大50.0平方迈，问哪年年底扩大到输入坐标处。对于输入(x,y)，以其为圆边界上的点，计算半圆的面积，除以50.0并向上取整后得到答案|

- [X] 1006

|[中国剩余定理](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)|
|:--|
|典型的中国剩余定理，这里通过手算[求出系数](https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Existence_(direct_construction))，乘以输入得到结果。求系数的过程中用到了[模逆元](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)|

- [X] 1007

|归并排序，逆序对问题|
|:--|
|典型的逆序对，在归并排序中插入逆序对计算代码即可|

- [X] 1008

|日历转换|
|:--|
|两种历法间的转换，简单|

- [X] 1009

|模拟+剪枝|
|:--|
|挺麻烦的模拟题。我基本的解题思路是这样的：
首先，一个像素的边缘检测结果只可能与它的上一行、它所在的行和它的下一行有关，所以在遍历每行时我维护了当前行和相邻行的信息
然后，对于遍历到的某一行，我用统一的列指针扫描它和它的相邻行
剪枝1：列指针扫描时，边缘检测结果出现变化的情况，仅可能由当前行或相邻行的像素值在扫描处邻域内的变化引起。那么求出像素值产生变化的扫描处，对于边缘检测结果不可能改变的位置就只需要计算一次即可
剪枝2：一个RLE对可能包含多行，中间重复行的边缘检测结果是连续的0，求出重复行的数量，就只需要向答案中添加0即可
思路可以说比较朴素，但写起来还是很麻烦的。
找到了[另一篇题解](http://blog.sina.com.cn/s/blog_6e63f59e01012mxb.html)，我觉得比我的好写，不过这种思路似乎需要特判一个区域外的点？|

- [ ] 1010

||
|:--|
||

- [ ] 1011

||
|:--|
||
